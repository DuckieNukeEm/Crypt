class CypherText:
	kind = 'Cypher'
	def __init__(self, plaintext, method='', key=0, cypher=''):
		self.plaintext = plaintext
		self.method = method
		self.key = key
		self.cypher = cypher
		
	def flip(self):
		NewPlainText = self.cypher
		NewCypher = self.plaintext
		self.plaintext = NewPlainText
		self.cypher = NewCypher
	def AlphaABC(self, ABC = False, round=False):
		if not round:
			if ABC:
				self.key = {a: a for a in list("abcdefghijklmnopqrstuvwxyz"+"ABCDEFGHIJKLMNOPQRSTUVWXYZ")}
			else:
				self.key = {a: a for a in list("abcdefghijklmnopqrstuvwxyz")}
		elif round:
			self.key={}
			if ABC:
				i = 0
				looper = len(round)
				for char in list("abcdefghijklmnopqrstuvwxyz"+"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
					self.key[char] = round[i % looper]
					i = i + 1 
			else:
				i = 0
				looper = len(round)
				for char in list("abcdefghijklmnopqrstuvwxyz")
					self.key[char] = round[i % looper]
					i = i + 1 
					
	def AlphaNum(self, ABC = False):
		abc = "abcdefghijklmnopqrstuvwxyz"
		
def CaesarOption():
	#this is the menu for the Caesar options
	print("Hail great Caesar, which option would you like to use?")
	print "1: Caesar Cypher"
	print "2: Crack Caesar cypher"
	print "3: Exit"
	answer = raw_input("?>")
	if answer == '1':
		d = CypherText(raw_input("Please print your plain text here: "), "CaesarCipher")
		d.key = int(raw_input("What key do you want to use? "))
		d.cypher = CaesarCipher(d.plaintext, d.key)
		print "This is the plain text: \n %s \n This is the Cypher Text: \n%s" % (d.plaintext, d.cypher)
		exit
	elif answer == '2':
		d = CypherText(raw_input("please input the cypher text here: "), "CeasarCrack")	
		if d.plaintext.lower() == d.plaintext or d.plaintext.upper() == d.plaintext:
			Rng = range(-25,1)
		else:
			Rng = range(-51,1)
		print "Offset : Crack"	
		for key in Rng:
			d.key = key
			d.cypher = CaesarCipher(d.plaintext,d.key)
			print "%r: %r" % (d.key, d.cypher)
		exit
	elif answer == '3':
		print 'Adios, Caesar!'
		return none
	else:
		print "eh? What was that? didn't hear you!"

def CaesarCipher(plaintext, key):
	#the purpose of this is to either create a Caesar Cipher or decrypt one by moving each letter
	#key number of places (if key is < 0, then we are moving backwards it)
	#this cypher will scramble symbols and numbers into a different range then alpha range
	if plaintext.lower() == plaintext:
		#all lower case
		for char in range(0,len(plaintext)):
			#-97 to get only lower case, adding key, mod 26, then + 97 for proper ASCI
			plaintext = plaintext[:char] +  chr((((ord(plaintext[char])- 97) + key) % 26) + 97) + plaintext[char + 1:]
			
	elif plaintext.upper() == plaintext:
		#all upper case
		for char in range(0,len(plaintext)):
			#-65 to get only upper case chars, adding key, mod 26, then + 65 for proper ASCI
			plaintext = plaintext[:char] +  chr((((ord(plaintext[char])- 65) + key) % 26) + 65) + plaintext[char + 1:] 
	else:
		#Both upper and lower case
		for char in range(0,len(plaintext)):
			ch = (((ord(plaintext[char])- 65) + key) % 58) + 65
			if ch in range(91,97): # moving through the [, \\ , ], ^,_,' of ASCII
				ch = ch + key/abs(key) * 6
			plaintext = plaintext[:char] +  chr(ch) + plaintext[char + 1:] 
	return plaintext

def AlphaDict(Upcase = False):
	#generates a dict with the same key and value pair
	alphabet = "abcdefghijklmnopqrstuvwxyz"
	if Upcase:
		alphabet = alphabet + alphabet.upper()
	return {al:al for al in list(alphabet)}

def partword(Word):
	i=0
	Rng = range(i,len(Word)+1)
	PrintWord = ''
	while i <= len(Word):
		PrintWord = PrintWord + Word[i:i+5] + ' '
		i = i + 5
	print PrintWord
	
def SubOption():
	#This is for the substitution cypher subscreen
	print "OOOOOOOO, panzy, here is the SUBSTITUION OPTIONS"
	print "1. Create a substitution cypher from plaintext"
	print "2. Crack a substitution"
	print "3. exit"
	ans = raw_input("?> ")
	if ans == '1':
		d = CypherText(raw_input("Please print your plain text here: "), "Substitution", AlphaAlphaDict())
		d.key = SubAlpha()
		d.cypher = SubCypher(d.plaintext, d.key)
		print("Here is the original Text: \n %r \n Here is the cypher: \n %r") % (d.plaintext, d.cypher)
		print d.key
		exit
	elif ans == '2':
		#d = CypherText(raw_input("please put in the cypher text: "),"Crack Substitution",{})
		d = CypherText("rgjjgmvktotzpgtstbgpcatjwpgocmgjs","Crack Substitution",{})
		while True:
			looper = raw_input("Would you like to guess a few translations? :").lower()
			if looper in ('y','ye','yes',' y',' ye',' yes','y ','ye ','yes '):
				d.key = SubAlpha(d.key)
			d.cypher, d.key = SubDecrypt(d.plaintext, d.key,d.cypher)
			if raw_input("Keep going? ").lower() in ('n','no',' n',' no','n ','no '):
				break
		exit
	else:
		exit
	
def SubAlpha(alpha={}):
	while True:
		print alpha.keys()
		print alpha.values()
		print "hit enter to quit"
		key = raw_input("What character do you want to replace? > ")
		if key == '':
			break
		value = raw_input("And what do you want to replace it with? > ")
		if key == '':
			break
		alpha[key] = value
	return alpha
	
def SubCypher(plaintext, alpha={}):
	#This does a substitution method
	#it returns the cypher and the dictionary used
	for i in range(0,len(plaintext)):
		plaintext = plaintext[:i] +  alpha.get(plaintext[i],plaintext[i]) + plaintext[char + 1:] 
	return  plaintext
	
def BuildAlpha(cypher, word, alpha={}):
	#checks to see if the cypher word is mapped to the proper word or blanke
	#then updates aplha with a new mapping or returns FALSE if a conflict arises
	for i in range(0,len(cypher)):
		if not alpha.has_key(cypher[i]) or alpha[cypher[i]] == word[i]:
			alpha[cypher[i]]=alpha.get(cypher[i],word[i])
		else:
			return False
	return alpha
		
def SubDecrypt(cypher, alpha = {},plaintext=''):
	guessword = raw_input("What word do you believe is in the cypher text? ")
	guessnum, guessmap = WordMapping(guessword)
	Rng = range(0,len(cypher) - len(guessword)+1)
	for i in Rng:
		
		Cyph, Cyphmap = WordMapping(cypher[i:i+len(guessword)])
		if Cyph == guessnum:
			print "We have a match! Cypher is %r \t Guess-word is %r" % (cypher[i:i+len(guessword)], guessword)
			print "Checking to see if it matches with the current dictionary:"
			if BuildAlpha(cypher[i:i+len(guessword)], guessword, alpha) == False:
				print "Looks like we have a match error, continuing down the path"
				continue
			print "match!"
	
	print "here is translation thus far:"
	partword(cypher)
	plaintext = SubCypher(cypher, alpha)
	partword(plaintext)
			
	return ( plaintext, alpha)
			
			
			
		
		
def WordMapping(String):
	String = list(String)
	OutStr = ''
	Map = {}
	Rmap = {}
	i = -1
	for char in String:
		if not Map.has_key(char):
			i = i + 1
		Map[char] = str(Map.get(char,i))
		Rmap[i] = char
		OutStr = OutStr + Map[char]
	return (''.join(OutStr), Rmap)

	
print "Welcome to the basic Cypher Crack, how may I help you?"
print "1: Caesar Options"
print "2: Simple substitution options"
print "3: Test the Cypher class"
ans =  raw_input("?> ")
if ans == '1':
	CaesarOption()
	exit
elif ans == '2':
	SubOption()
	exit
else:
	exit
