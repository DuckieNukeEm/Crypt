class CypherText:
	kind = 'Cypher'
	def __init__(self, plaintext, method='', key=0, cypher=''):
		self.plaintext = plaintext
		self.method = method
		self.key = key
		self.cypher = cypher
		
	def flip(self):
		NewPlainText = self.cypher
		NewCypher = self.plaintext
		self.plaintext = NewPlainText
		self.cypher = NewCypher

def CaesarOption():
	#this is the menu for the Caesar options
	print("Hail great Caesar, which option would you like to use?")
	print "1: Caesar Cypher using ASCII"
	print "2: Caesar Cypher using alphabet"
	print "3: Crack Caesar cypher using ASCII"
	print "4: Crack Caesar cypher using alphabet"
	print "5: Exit"
	answer = raw_input("?>")
	if answer == '1':
		#SHIT just realized the CaesarCipherASCII does the same as CaesarCipher with Upper = True
		d = CypherText(raw_input("Please print your plain text here: "), "CaesarCipherASCII")
		d.key = int(raw_input("What key do you want to use? "))
		d.cypher = CaesarCipher(d.plaintext, d.key, IsUpper(d.plaintext))
		print "This is the plain text: \n %s \n This is the Cypher Text:\n%s" % (d.plaintext, d.cypher)
		exit
	elif answer == '2':
		d = CypherText(raw_input("Please print your plain text here: "), "CaesarCipher")
		d.key = int(raw_input("What key do you want to use? "))
		d.cypher = CaesarCipher(d.plaintext, d.key, IsUpper(d.plaintext))
		print "This is the plain text: \n %s \n This is the Cypher Text:\n%s" % (d.plaintext, d.cypher)
		exit
	elif answer == '3':
		d = Cyphertext(raw_input("please input the cypher text here: "), "CeasarCrackASCII")
		print "Offset : Crack"
		for key in range(-255,0):
			d.key = key
			d.cypher = CaesarCipherASCII(d.plaintext,d.key)
			print "%r: %r" % (d.key, d.cypher)
		exit
	elif answer == '4':
		d = Cyphertext(raw_input("please input the cypher text here: "), "CeasarCrack")
		print "Offset : Crack"
		if IsUpper(d.plaintext):
			Rng = range(-51,0)
		else:
			Rng = range(-25,0)
		for key in Rng:
			d.key = key
			d.cypher = CaesarCipher(d.plaintext,d.key,IsUpper(d.plaintext))
			print "%r: %r" % (d.key, d.cypher )
		exit
	elif answer == '5':
		print 'Adios! Cesar'
		return none
	else:
		print "eh? What was that? didn't hear you!"

def AlphaNumDict(UpCase = False):
	#creating two dictionarys, one that will map chars to a number
	#and another that will map number to chars
	alphabet = "abcdefghijklmnopqrstuvwxyz"
	if UpCase:
		alphabet = alphabet + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
	alphabet = list(alphabet)
	alphanum = {}
	numalpha = {}
	index = 0
	for char in alphabet:
		alphanum[char] = index
		numalpha[index] = char
		index = index + 1
	return (alphanum, numalpha)

def CaesarCipherASCII( plaintext, key):
	#the purpose of this is to either create a Caesar Cipher or decrypt one by moving each letter
	#key number of places (if key is < 0, then we are moving backwards it)
	#this cypher uses all 256 characters in ASCII
	plaintextlist = list(plaintext)
	cypherlist = []
	
	for char in plaintextlist:
		cypherlist.append(chr((ord(char) + key) % 256))
		
	return ''.join(cypherlist)

def CaesarCipher(plaintext, key, UpCase = False):
	# the purpose of this is to either create a Caesar Cipher or decrypt on by moving each letter
	# key number of places (if key is < 0, then we are decrypting it)
	# this cypher uses on 26 characters of the alphabet
	plaintextlist = list(plaintext)
	cypherlist = []
	alphanum, numalpha = AlphaNumDict(UpCase)
	for char in plaintextlist:
		if char.isdigit():
			cypherlist.append(str((int(char) + key) % 10))
		elif char in alphanum:
			cypherlist.append(numalpha[(alphanum[char] + key) % (len(alphanum)-1)])
		else:
			cypherlist.append(char)
	return ''.join(cypherlist)

def AlphaAlphaDict(Upcase = False):
	#generates a dict with the same key and value pair
	alphabet = "abcdefghijklmnopqrstuvwxyz"
	if Upcase:
		alphabet = alphabet + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
	alphabet = list(alphabet)
	AlphaAlpha = {}
	for char in alphabet:
		AlphaAlpha[char] = char
	return AlphaAlpha

def IsUpper(Str):
	#Checks if there are uppper case letters in a string
	if Str.find(Str.lower()) == Str.find(Str.upper()) or Str.find(Str.upper()) == 0:
		return True
	return False

def SubOption():
	#This is for the substitution cypher subscreen
	print "OOOOOOOO, panzy, here is the SUBSTITUION OPTIONS"
	print "1. Create a substitution cypher from plaintext"
	print "2. Crack a substitution"
	print "3. exit"
	ans = raw_input("?> ")
	if ans == '1':
		d = CypherText(raw_input("Please print your plain text here: "), "Substitution", AlphaAlphaDict())
		d.key = SubAlpha()
		d.cypher = SubCypher(d.plaintext, d.key)
		print("Here is the original Text: \n %r \n Here is the cypher: \n %r") % (d.plaintext, d.cypher)
		print d.key
		exit
	elif ans == '2':
		looper = raw_input("Welcome, press enter to proceed")
		#d = CypherText(raw_input("please put in the cypher text: "),"Crack Substitution",{})
		d = CypherText("yjratrdofrmyesdlozzrfurdyrtfsu","Crack Substitution",{})
		while True:
			looper = raw_input("Would you like to guess a few translations? :").lower()
			if looper in ('y','ye','yes',' y',' ye',' yes','y ','ye ','yes '):
				d.key = SubAlpha(d.key)
			d.cypher, d.key = SubDecrypt(d.plaintext, d.key,d.cypher)
			if raw_input("Keep going? ").lower() in ('n','no',' n',' no','n ','no '):
				break
		exit
	else:
		exit
	
def SubAlpha(alpha={}):
	map = alpha
	while True:
		print map.keys()
		print map.values()
		print "type qq to quit"
		key = raw_input("What character do you want to replace? > ")
		if key == 'qq':
			break
		value = raw_input("And what do you want to replace it with? >")
		if key == 'qq':
			break
		alpha[key] = value
		map[key] = value
	return alpha
	
def SubCypher(plaintext, alpha={}):
	#This does a substitution method
	#it returns the cypher and the dictionary used
	plaintextlist = list(plaintext)
	cypherlist = []
	for char in plaintextlist:
		cypherlist.append(alpha.get(char,char))
	return (''.join(cypherlist))
	
def BuildAlpha(cypher, word, alpha={}):
	#checks to see if the cypher word is mapped to the proper word or blanke
	#then updates aplha with a new mapping or returns FALSE if a conflict arises
	for i in range(0,len(cypher)):
		if not alpha.has_key(cypher[i]) or alpha[cypher[i]] == word[i]:
			alpha[cypher[i]]=alpha.get(cypher[i],word[i])
		else:
			return False
	return alpha
		
def SubDecrypt(cypher, alpha = {},plaintext=''):
	guessword = raw_input("What word do you believe is in the cypher text? ")
	guessnum, guessmap = WordMapping(guessword)
	Rng = range(0,len(cypher) - len(guessword)+1)
	for i in Rng:
		
		Cyph, Cyphmap = WordMapping(cypher[i:i+len(guessword)])
		if Cyph == guessnum:
			print "We have a match! Cypher is %r \t Guess-word is %r" % (cypher[i:i+len(guessword)], guessword)
			print "Checking to see if it matches with the current dictionary:"
			if BuildAlpha(cypher[i:i+len(guessword)], guessword, alpha) == False:
				print "Looks like we have a match error, continuing down the path"
				continue
			print "match!"
			print "here is translation thus far:"
			print cypher
			plaintext = SubCypher(cypher, alpha)
			print plaintext
			
	return ( plaintext, alpha)
			
			
			
		
		
def WordMapping(String):
	String = list(String)
	OutStr = ''
	Map = {}
	Rmap = {}
	i = -1
	for char in String:
		if not Map.has_key(char):
			i = i + 1
		Map[char] = str(Map.get(char,i))
		Rmap[i] = char
		OutStr = OutStr + Map[char]
	return (''.join(OutStr), Rmap)

	
print "Welcome to the basic Cypher Crack, how may I help you?"
print "1: Caesar Options"
print "2: Simple substitution options"
print "3: Test the Cypher class"
ans =  raw_input("?> ")
if ans == '1':
	CaesarOption()
	exit
elif ans == '2':
	SubOption()
	exit
else:
	exit
